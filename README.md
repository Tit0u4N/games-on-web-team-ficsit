# Olympic Odyssey (ðŸ¥‰3rd rankðŸ¥‰)

## Overview

Welcome we're excited to develop an innovative game that combines management,
4X and adventure elements, all set in the thrilling world of the Olympic Games for the Games On Web tournament.
Inspired by the game [For the King](https://store.steampowered.com/app/527230/For_The_King/)
and [Baldur's Gate III](https://store.steampowered.com/app/1086940/Baldurs_Gate_3/) for the gameplay.

> **Note:**
> If you prefer to read this document in French, please scroll down to the [French Version ðŸ‡«ðŸ‡·](#olympic-odyssey-).

- [Game Link](https://tit0u4n.github.io/games-on-web-team-ficsit/)
- [Repository Github](https://github.com/Tit0u4N/games-on-web-team-ficsit)
- [Video Presentation](https://youtu.be/Ws0oB_I-Yis)
- [Team Members](#team-members)
- [Technology Stack](#technology-stack)
- [Key-development-points](#Key-development-points)
  - [Step 1: Generating the Map](#step-1-generating-the-map)
  - [Step 2: The Dice](#step-2-the-dice)
  - [Step 3: The Environment](#step-3-the-environment)
  - [Step 4: React](#step-4-react)
  - [Step 5: Animations](#step-5-animations)
  - [Step 6: Movement](#step-6-movement)
- [Development Approach](#development-approach)
  - [Package Management](#package-management)
  - [Getting Started](#getting-started)

## Team Members

- **[Titouan Lacombe--Fabre](https://github.com/Tit0u4N)** (L3 MIAGE, MIAGE Nice - Sophia)
- **[Tamas Palotas](https://github.com/Shiyamii)** (Bachelor degree in computer science *BUT 3*, Nice)
- **[Baptiste Lacroix](https://github.com/BaptisteLacroix)** (SI3 FISA, Diploma in computer engineering, Polytech Nice
  Sophia)

## Technology Stack

Our project is built using a robust and modern technology stack to ensure a high-quality gaming experience:

- **Primary Libraries:**
  - **BabylonJS**: For rendering stunning 3D graphics and creating immersive game environments.
  - **React**: To build a dynamic and responsive user interface.

- **Secondary Libraries:**
  - **NextUI**: For a modern and responsive UI design.
  - **Tailwind**: For sleek and efficient styling.
  - **SCSS**: To enhance CSS with more advanced styling capabilities.

- **Programming Language:** The entire project is written in **TypeScript**, utilizing its strong typing features for
  better code quality and maintainability.

- **Build Tool:** We use **Vite** for fast and efficient building and development.

- **Testing Framework:** We use **Jest** for testing our codebase.

- **Formatters and Linters:** We use **Prettier** and **ESLint** to ensure consistent code style and quality.

### The Idea

To create our game, we wanted to stand out by choosing a different type of game. We decided to develop a strategy, and
adventure game, inspired by titles like *For the King* and *Baldur's Gate III*.

We envisioned a game board made up of hexagonal tiles, featuring two types of buildings:

- Training centers, which allow our athletes to improve their skills.
- Arenas, where teams can battle other teams to win items.

Then, we imagined a final competition representing the Olympic Games after four years. The goal is to earn the most
points. There is a tournament for each sport to accumulate points. Each team is composed of three athletes, and the
ranking is done by team.

## Key development points

### Step 1: Generating the Map

To generate the map, we used Perlin noise and then added an algorithm to give our map an island shape.
For this, we used a Node.js library called 'tumult' which allows generating Perlin noise.
To use the library in our project, we encapsulated the code in a `Noise` class in TypeScript.

<p align="center">
  <img src="./images/perlin_1.png" alt="Perlin Noise Image" width="35%" />
  <img src="./images/perlin_2.png" alt="Perlin Noise Image" width="55%" />
  <img src="./images/perlin_3.png" alt="Perlin Noise Image" width="90%" />
</p>

To generate the map as we wanted, we adjusted the algorithm until we achieved the desired result.

### Step 2: The Dice

As dice rolling is at the heart of the game, we decided to give the player two options:

#### 2D Dice Roll

We first created a way to roll the dice in 2D, which is faster.
<p align="center">
  <img src="./images/dice_2d.png" alt="2D Dice Roll" width="80%" />
</p>

#### 3D Dice Roll

Next, we decided to create a 3D dice roll to make the game more immersive. For this, we needed to enable physics in
Babylon.js via Havok.
This was one of the biggest challenges because Havok is coded in WebAssembly (Wasm), so we had to handle its
asynchronous loading at the start of the game.
Additionally, adding a Wasm plugin to ViteJS was necessary.

<p align="center">
  <img src="./images/dice_3d_1.png" alt="3D Dice Roll" width="40%" />
  <img src="./images/dice_3d_2.png" alt="3D Dice Roll" width="55%" />
</p>

Once the physics were enabled, we were able to create and roll a 3D dice. However, the dice texture and the detection of
the "winning" face were issues to resolve.
For the texture, we faced inverted FaceUVs compared to what we wanted. To fix this, we reversed the texture direction
instead of recalculating the FaceUVs with a mathematical formula.

For detecting the "winning" face, we tested several methods. Initially, we wanted to detect the face whose vector
pointed upwards, but due to a high error rate, we switched to a simpler method of detecting the highest face. There may
still be errors, but the margin of error is much lower.

### Step 3: The Environment

For the environment, we decided to adopt a cartoon style to make the game more fun and accessible.
Low poly was a good choice as it is simpler to implement for us who are not experienced in 3D.

<p align="center">
  <img src="./images/decors_1.png" alt="Environment" width="98%" />
</p>

Most of our environment assets were trees and rocks that we created using Blender. For the buildings, we used free 3D
models found online.
The buildings were not an issue as there were few of them.

For the trees and rocks, there were a lot of 3D objects, up to about 18,400 trees and 3,350 rocks. Creating these 3D
objects directly required a lot of resources, so we decided to create instances of these objects, specifically "
ThinInstance", allowing us to create copies of the same 3D object without consuming additional resources. However, "
ThinInstance" prevented us from handling clicks or managing objects independently. To address this, we created a `Decor`
class that allowed us to manage all aspects of our environment and create multiple versions to show different trees (
shape, size, rotation).

<p align="center">
  <img src="./images/decors_2.png" alt="Environment" width="98%" />
  Images of trees and rocks during the early implementation (a bit demoralizing)
</p>

### Step 4: React

To build our user interface, we decided to use React for its simplicity and ease of use. However, React has its own
execution thread and becomes very finicky when we want to step outside of it. Fortunately, `useState` are functions and
can easily be passed into a function outside a React component.
In 95% of cases, this method works and allows React to update automatically. But in some cases, such as loading the
Havok physics engine or creating the map, we had to use `useEffect` with a `setTimeout` to force React to update.

Another challenge was managing modals and popups. For this, we created a `Modal` class that is a singleton and manages
almost all the game's modals. With a constraint, classes wanting a modal had to implement the `Reactable` interface to
ensure the management of certain methods.

### Step 5: Animations

To enhance the interactivity and appeal of the game, we decided to implement animations for the 3D character models in
the game. However, we encountered difficulties in animating the characters in the game. Initially, we used the custom global
function `importModel` to import 3D models with their animations into the BabylonJS scene. Despite the presence of
animations in the `AnimationGroups`, the characters appeared in a static (Blender) pose, and no animation was triggered.

To solve this problem, we rethought our approach and implemented a new function called `importMesh` within the `Pawn`
class. This function uses `SceneLoader.ImportMesh` to import the model and its animations. Hereâ€™s how our approach
evolved:

#### Previous Approach (`importModel`):

The `importModel` function was responsible for importing 3D models into the scene. However, despite the presence of
animations in the imported model, they were not triggered, and the characters appeared static. We
used `SceneLoader.ImportMeshAsync` for the import, hoping the animations would work without issue.

#### New Approach (`importMesh`):

In the revised approach, we introduced the `importMesh` function, using `SceneLoader.ImportMesh`. This function imports
the model and animations differently. Hereâ€™s what changed:

- **Parenting Meshes**: We created a parent mesh (`outer`) for the model and attached the model to this parent. This
  step was crucial as it provided a stable reference frame for the animations to apply correctly.

- **Managing Animations**: We properly configured the animations from the `AnimationGroups` obtained during the import.
  By directly accessing the `animationGroups` parameter in the import callback, we ensured the animations were correctly
  associated with the model.

#### Impact:

By adopting the new approach, we successfully resolved the animation issue. The characters are now animated as expected,
adding dynamism and immersion to the game world. The introduction of a parent mesh and proper animation configuration
significantly improved the integration of animations in our game, enhancing the overall gaming experience.

### Step 6: Movement

To move our characters, we had to create a movement system. For this, we used a graph defined across the entire map that
defines possible movements and movement costs. For this, we used the `data-structures` library, which allows easy
creation of graphs. Once the graph was created, it had to be displayed in 3D without being too heavy on calculations.

<p align="center">
  <img src="./images/displacement_1.png" alt="Character Movement" width="70%" />
</p>

Thanks to the library, we could easily determine all reachable tiles within a certain number of movement points. Once
these tiles were defined, they just needed to be made clickable, and the character would move to them.

## Development Approach

Our development follows the **Model-View-Presenter (MVP)** architecture. This approach allows us to separate the logic,
UI, and data handling aspects of the project, making our code more modular, scalable, and easier to manage.

### Package Management

We use **Yarn** as our package manager. The following commands are essential for working with our project:

- `yarn install`: To install all the necessary dependencies.
- `yarn run dev`: To start the development server.
- `yarn build`: To build the project for production.
- `yarn test`: To run the test suite.
- `yarn format`: To run the code formatter.

### Getting Started

To get started with contributing to this project, please follow these steps:

1. Clone the repository.
2. Run `yarn install` to install all dependencies.
3. Create a new branch for your feature following the naming convention.
4. Develop your feature and commit your changes.
5. Push your branch and open a pull request for review.

# Olympic Odyssey ðŸ‡«ðŸ‡· (ðŸ¥‰3Ã¨me placeðŸ¥‰)

## AperÃ§u

Bienvenue, nous sommes ravis de dÃ©velopper un jeu innovant qui combine des Ã©lÃ©ments de gestion,
4X et d'aventure, le tout dans le monde passionnant des Jeux Olympiques pour le tournoi Games On Web.
InspirÃ© par le jeu [For the King](https://store.steampowered.com/app/527230/For_The_King/)
et [Baldur's Gate III](https://store.steampowered.com/app/1086940/Baldurs_Gate_3/) pour le gameplay.

- [Lien du Jeu](https://tit0u4n.github.io/games-on-web-team-ficsit/)
- [Repository Github](https://github.com/Tit0u4N/games-on-web-team-ficsit)
- [PrÃ©sentation VidÃ©o](https://youtu.be/Ws0oB_I-Yis)
- [Membres de l'Ã©quipe](#membres-de-lÃ©quipe)
- [Stack Technologique](#stack-technologique)
- [Points-clÃ©s-du-dÃ©veloppement](#point-clÃ©-du-dÃ©veloppement)
  - [Ã‰tape 1: GÃ©nÃ©ration de la Carte](#Ã©tape-1--gÃ©nÃ©ration-de-la-carte)
  - [Ã‰tape 2: Les DÃ©s](#Ã©tape-2--le-dÃ©)
  - [Ã‰tape 3: L'Environnement](#Ã©tape-3--les-dÃ©cors)
  - [Ã‰tape 4: React](#Ã©tape-4--react)
  - [Ã‰tape 5: Les Animations](#Ã©tape-5--les-animations)
  - [Ã‰tape 6: DÃ©placements](#Ã©tape-6--les-dÃ©placements)
- [Approche de DÃ©veloppement](#approche-de-dÃ©veloppement)
  - [Gestion des Packages](#gestion-des-packages)
  - [Pour Commencer](#pour-commencer)

## Membres de l'Ã©quipe

- **[Titouan Lacombe--Fabre](https://github.com/Tit0u4N)** (L3 MIAGE, MIAGE Nice - Sophia)
- **[Tamas Palotas](https://github.com/Shiyamii)** (Licence en informatique *BUT 3*, Nice)
- **[Baptiste Lacroix](https://github.com/BaptisteLacroix)** (SI3 FISA, DiplÃ´me en ingÃ©nierie informatique, Polytech Nice
  Sophia)

## Stack Technologique

Notre projet est construit en utilisant une stack technologique robuste et moderne pour garantir une expÃ©rience de jeu de haute qualitÃ© :

- **BibliothÃ¨ques Principales :**
  - **BabylonJS** : Pour rendre des graphismes 3D Ã©poustouflants et crÃ©er des environnements de jeu immersifs.
  - **React** : Pour construire une interface utilisateur dynamique et rÃ©active.

- **BibliothÃ¨ques Secondaires :**
  - **NextUI** : Pour un design d'interface utilisateur moderne et rÃ©actif.
  - **Tailwind** : Pour un style Ã©lÃ©gant et efficace.
  - **SCSS** : Pour amÃ©liorer le CSS avec des capacitÃ©s de style plus avancÃ©es.

- **Langage de Programmation :** L'ensemble du projet est Ã©crit en **TypeScript**, utilisant ses fonctionnalitÃ©s de typage fort pour
  une meilleure qualitÃ© et maintenabilitÃ© du code.

- **Outil de Build :** Nous utilisons **Vite** pour un build et un dÃ©veloppement rapides et efficaces.

- **Framework de Test :** Nous utilisons **Jest** pour tester notre code.

- **Formatters et Linters :** Nous utilisons **Prettier** et **ESLint** pour garantir un style de code et une qualitÃ© cohÃ©rents.

### L'idÃ©e de base

Pour crÃ©er notre jeu, nous souhaitions nous dÃ©marquer en optant pour un type de jeu diffÃ©rent des autres.
Nous avons donc dÃ©cidÃ© de dÃ©velopper un jeu de stratÃ©gie et d'aventure, en nous inspirant de titres comme *For the King* et *Baldur's Gate III*.

Nous avons imaginÃ© un plateau de jeu composÃ© de cases hexagonales, avec deux types de bÃ¢timents :

- Les centres d'entraÃ®nement, qui permettent d'amÃ©liorer les compÃ©tences de nos athlÃ¨tes.
- Les arÃ¨nes, oÃ¹ les Ã©quipes peuvent combattre d'autres Ã©quipes pour gagner des objets.

Ensuite, nous avons imaginÃ© une compÃ©tition finale reprÃ©sentant les Jeux Olympiques au bout de quatre ans. Le but est d'obtenir le plus de points possible. Il y a un tournoi par sport pour accumuler les points. Chaque Ã©quipe est composÃ©e de trois athlÃ¨tes et le classement se fait par Ã©quipe.


## Point clÃ© du dÃ©veloppement

### Ã‰tape 1 : GÃ©nÃ©ration de la carte

Pour gÃ©nÃ©rer la carte, nous avons utilisÃ© le bruit de Perlin, puis ajoutÃ© un algorithme afin de donner une forme d'Ã®le Ã 
notre carte.
Pour cela, nous avons utilisÃ© une librairie Node.js appelÃ©e 'tumult' qui permet de gÃ©nÃ©rer des bruits de Perlin.
Afin de pouvoir utiliser la librairie dans notre projet, nous avons dÃ» encapsuler le code dans une classe `Noise` en
TypeScript.

<p align="center">
  <img src="./images/perlin_1.png" alt="Image bruit de Perlin" width="35%" />
  <img src="./images/perlin_2.png" alt="Image bruit de Perlin" width="55%" />
  <img src="./images/perlin_3.png" alt="Image bruit de Perlin" width="90%" />
</p>

Pour gÃ©nÃ©rer la carte comme nous le souhaitions, nous avons ajustÃ© l'algorithme jusqu'Ã  obtenir le rÃ©sultat souhaitÃ©.

### Ã‰tape 2 : Le dÃ©

Le lancer de dÃ© Ã©tant au cÅ“ur du jeu, nous avons dÃ©cidÃ© de donner au joueur deux possibilitÃ©s :

#### Lancer de dÃ© en 2D

Nous avons d'abord crÃ©Ã© une faÃ§on de lancer le dÃ© en 2D, plus rapide.
<p align="center">
  <img src="./images/dice_2d.png" alt="Lancer de dÃ© en 2D" width="80%" />
</p>

#### Lancer de dÃ© en 3D

Ensuite, nous avons dÃ©cidÃ© de crÃ©er un lancer de dÃ© en 3D pour rendre le jeu plus immersif. Pour cela, il fallait
activer la physique dans Babylon.js via Havok.
Ce fut l'un des plus gros problÃ¨mes Ã  gÃ©rer car Havok est codÃ© en WebAssembly (Wasm) et il fallait donc gÃ©rer son
chargement de maniÃ¨re asynchrone au dÃ©but du jeu.
De plus, l'ajout d'un plugin Wasm Ã  ViteJS Ã©tait nÃ©cessaire.

<p align="center">
  <img src="./images/dice_3d_1.png" alt="Lancer de dÃ© en 3D" width="40%" />
  <img src="./images/dice_3d_2.png" alt="Lancer de dÃ© en 3D" width="55%" />
</p>

Une fois la physique activÃ©e, nous avons pu crÃ©er un dÃ© en 3D et le lancer. Cependant, la texture du dÃ© ainsi que la
dÃ©tection de la face "gagnante" furent des problÃ¨mes Ã  rÃ©soudre.
Pour la texture, nous avons dÃ» faire face aux FaceUV qui Ã©taient totalement inversÃ©es par rapport Ã  ce que nous
voulions. Pour rÃ©gler ce problÃ¨me, nous avons inversÃ© le sens de la texture plutÃ´t que de remettre les FaceUV Ã 
l'endroit via une formule mathÃ©matique.

Pour la dÃ©tection de la face "gagnante", nous avons testÃ© plusieurs mÃ©thodes. Initialement, nous voulions dÃ©tecter la
face dont le vecteur pointait vers le haut, mais en raison d'un taux d'erreur trop Ã©levÃ©, nous nous sommes rabattus sur
une mÃ©thode plus simple consistant Ã  dÃ©tecter la face la plus haute. Il peut encore y avoir des erreurs, mais la marge
d'erreur est beaucoup plus faible.

### Ã‰tape 3 : Les dÃ©cors

Pour les dÃ©cors, nous avons dÃ©cidÃ© d'adopter un style cartoon pour rendre le jeu plus fun et accessible.
Le low poly Ã©tait un bon choix car il est plus simple Ã  mettre en place pour nous qui ne sommes pas expÃ©rimentÃ©s en 3D.

<p align="center">
  <img src="./images/decors_1.png" alt="DÃ©cors" width="98%" />
</p>

La majoritÃ© de nos dÃ©cors Ã©taient des arbres et des rochers que nous avons crÃ©Ã©s en utilisant Blender. Pour les
bÃ¢timents, nous avons utilisÃ© des modÃ¨les 3D gratuits trouvÃ©s sur internet.
Les bÃ¢timents n'ont pas posÃ© de problÃ¨me car il y en avait peu.

Pour les arbres et les rochers, il y avait Ã©normÃ©ment d'objets 3D, jusqu'Ã  environ 18 400 arbres et 3 350 rochers. CrÃ©er
directement ces objets 3D demandait beaucoup de ressources, nous avons donc dÃ©cidÃ© de crÃ©er des instances de ces objets,
plus exactement des "ThinInstance", permettant de crÃ©er des copies d'un mÃªme objet 3D sans consommer de ressources
supplÃ©mentaires. Cependant, les "ThinInstance" nous empÃªchaient de gÃ©rer les clics ou de gÃ©rer les objets
indÃ©pendamment. Pour cela, nous avons crÃ©Ã© une classe `Decor` qui nous permet de gÃ©rer tous les aspects de nos dÃ©cors et
d'en crÃ©er plusieurs versions afin de montrer plusieurs arbres diffÃ©rents (forme, taille, rotation).

<p align="center">
  <img src="./images/decors_2.png" alt="DÃ©cors" width="98%" />
  Images des arbres et des rochers lors des dÃ©buts de l'implÃ©mentation (petit coup au moral)
</p>

### Ã‰tape 4 : React

Pour construire notre interface utilisateur, nous avons dÃ©cidÃ© d'utiliser React pour sa simplicitÃ© et sa facilitÃ©.
Cependant, React a un fil d'exÃ©cution bien Ã  lui et devient trÃ¨s capricieux lorsque nous voulons en sortir.
Heureusement, les `useState` sont des fonctions et peuvent donc facilement Ãªtre transmises dans une fonction hors d'un
composant React.
Dans 95% des cas, cette mÃ©thode fonctionne et permet Ã  React de se mettre Ã  jour automatiquement. Mais dans certains
cas, comme le chargement du moteur physique Havok ou la crÃ©ation de la carte, nous avons dÃ» utiliser des `useEffect`
avec un `setTimeout` pour forcer React Ã  se mettre Ã  jour.

Une autre difficultÃ© rencontrÃ©e Ã©tait la gestion des modals et des popups. Pour cela, nous avons crÃ©Ã© une classe `Modal`
qui est un singleton et qui s'occupe de gÃ©rer quasiment toutes les modals du jeu. En ayant une contrainte, les classes
voulant une modal devaient implÃ©menter l'interface `Reactable` qui permettait de garantir la gestion de certaines
mÃ©thodes.

### Ã‰tape 5 : Les animations

Pour amÃ©liorer l'interactivitÃ© et l'attrait du jeu, nous avons dÃ©cidÃ© d'implÃ©menter des animations pour les modÃ¨les de
personnages en 3D dans le jeu. Cependant, nous avons rencontrÃ© des difficultÃ©s pour animer les personnages dans le jeu.
Initialement, nous utilisions la fonction custom globale `importModel` pour importer des modÃ¨les 3D avec leurs animations dans
la scÃ¨ne BabylonJS. MalgrÃ© la prÃ©sence des animations dans les `AnimationGroups`, les personnages apparaissaient en pose
statique (Blender), et aucune animation n'Ã©tait dÃ©clenchÃ©e.

Pour rÃ©soudre ce problÃ¨me, nous avons repensÃ© notre approche et implÃ©mentÃ© une nouvelle fonction appelÃ©e `importMesh` Ã 
l'intÃ©rieur de la classe `Pawn`. Cette fonction utilise `SceneLoader.ImportMesh` pour importer le modÃ¨le et ses
animations. Voici comment notre approche a Ã©voluÃ© :

#### Approche prÃ©cÃ©dente (`importModel`):

La fonction `importModel` Ã©tait responsable de l'importation des modÃ¨les 3D dans la scÃ¨ne. Cependant, malgrÃ© la prÃ©sence
des animations dans le modÃ¨le importÃ©, elles n'Ã©taient pas dÃ©clenchÃ©es et les personnages apparaissaient statiques. Nous
utilisions `SceneLoader.ImportMeshAsync` pour l'importation, en espÃ©rant que les animations fonctionnent sans problÃ¨me.

#### Nouvelle approche (`importMesh`):

Dans l'approche rÃ©visÃ©e, nous avons introduit la fonction `importMesh`, en utilisant `SceneLoader.ImportMesh`. Cette
fonction importe le modÃ¨le et les animations diffÃ©remment. Voici ce qui a changÃ© :

- **Parentage des meshes** : Nous avons crÃ©Ã© un mesh parent (`outer`) pour le modÃ¨le et attachÃ© le modÃ¨le Ã  ce parent.
  Cette Ã©tape Ã©tait cruciale car elle fournissait un cadre de rÃ©fÃ©rence stable pour que les animations s'appliquent
  correctement.

- **Gestion des animations** : Nous avons correctement configurÃ© les animations Ã  partir des `AnimationGroups` obtenus
  lors de l'importation. En accÃ©dant directement au paramÃ¨tre `animationGroups` du callback d'importation, nous avons
  assurÃ© que les animations Ã©taient correctement associÃ©es au modÃ¨le.

#### Impact :

En adoptant la nouvelle approche, nous avons rÃ©ussi Ã  rÃ©soudre le problÃ¨me d'animation. Les personnages sont dÃ©sormais
animÃ©s comme prÃ©vu, ajoutant du dynamisme et de l'immersion au monde du jeu. L'introduction d'un mesh parent et une
configuration correcte des animations ont considÃ©rablement amÃ©liorÃ© l'intÃ©gration des animations dans notre jeu,
amÃ©liorant l'expÃ©rience globale de jeu.

### Ã‰tape 6 : Les dÃ©placements

Afin de pouvoir dÃ©placer nos personnages, nous avons dÃ» crÃ©er un systÃ¨me de dÃ©placement. Pour cela, nous avons utilisÃ©
un graphe dÃ©fini sur toute la carte qui dÃ©finit les dÃ©placements possibles et les coÃ»ts de dÃ©placement. Pour cela, nous
avons utilisÃ© la librairie `data-structures` qui permet de crÃ©er des graphes facilement. Une fois le graphe crÃ©Ã©, il
fallait le faire afficher en 3D sans que ce soit trop lourd en calcul.

<p align="center">
  <img src="./images/displacement_1.png" alt="DÃ©placement des personnages" width="70%" />
</p>

GrÃ¢ce Ã  la librairie, nous pouvions facilement dÃ©terminer toutes les cases atteignables en un certain nombre de points
de mouvement. Une fois ces cases dÃ©finies, il suffisait de les rendre cliquables et de faire bouger le personnage
dessus.


## Approche de DÃ©veloppement

Notre dÃ©veloppement suit l'architecture **Model-View-Presenter (MVP)**. Cette approche nous permet de sÃ©parer la logique,
l'interface utilisateur et la gestion des donnÃ©es du projet, rendant notre code plus modulaire, Ã©volutif et plus facile Ã  gÃ©rer.

### Gestion des Packages

Nous utilisons **Yarn** comme gestionnaire de packages. Les commandes suivantes sont essentielles pour travailler avec notre projet :

- `yarn install` : Pour installer toutes les dÃ©pendances nÃ©cessaires.
- `yarn run dev` : Pour dÃ©marrer le serveur de dÃ©veloppement.
- `yarn build` : Pour construire le projet pour la production.
- `yarn test` : Pour exÃ©cuter la suite de tests.
- `yarn format` : Pour exÃ©cuter le formateur de code.

### Pour Commencer

Pour commencer Ã  contribuer Ã  ce projet, veuillez suivre ces Ã©tapes :

1. Cloner le repository.
2. ExÃ©cuter `yarn install` pour installer toutes les dÃ©pendances.
3. CrÃ©er une nouvelle branche pour votre fonctionnalitÃ© en suivant la convention de nommage.
4. DÃ©velopper votre fonctionnalitÃ© et valider vos modifications.
5. Pousser votre branche et ouvrir une pull request pour rÃ©vision.
